---
layout: post
title:  OpenGL Rendering Pipeline
date:   2016-1-16 14:30
categories: coding
---

OpenGL渲染管线（rendering pipeline）是一系列数据处理过程，并且将应用程序的数据转换到最终渲染的图像。OpenGL接收用户提供的几何数据（顶点和几何图元），并且将它输入到一系列着色器阶段中进行处理，包括：顶点着色、细分着色（包括两个着色器），以及最后的几何着色，然后它将被送入光栅化单元（rasterizer）。光栅化单元负责对所有剪切区域（clipping region）内的图元生成片元数据，然后对每个生成的片元都执行一个片元着色器。如下图：

![OpenGL Rendering Pipeline](/images/OpenGL-Pipeline.png)

OpenGL需要将所有的数据都保存到缓存对象（buffer object）中，它相当于由OpenGL服务端维护的一块内存区域。我们可以用多种方式来创建这样的数据缓存，glBufferData()是最常用的命令，我们还可以对缓存做一些额外的设置。OpenGL的绘制通常就是将顶点数据传输到OpenGL服务端。我们可以将一个顶点视为一个需要统一处理的数据包。这个包中的数据可以是我们需要的任何数据，通常其中几乎始终会包含位置数据，其他的数据可能用来决定一个像素的最终颜色。

##1.顶点着色

对于绘制命令传输的每个顶点，OpenGL都会调用一个顶点着色器来处理顶点相关的数据。根据其他光栅化之前的着色器的活跃与否，顶点着色器可能非常简单，例如，只是将数据复制并传递到下一个着色阶段，这个叫做传递着色器（pass-through shader）；它也可能非常复杂，例如，执行大量的计算来得到顶点在屏幕上的位置（一般情况下，会用到变换矩阵transformation matrix）或者通过光照的计算来判断顶点的颜色，或者其他一些技法的实现。一个复杂的应用程序可能包含许多个顶点着色器，但是在同一时刻只能有一个顶点着色器起作用。

##2.细分着色
	
顶点着色器处理每个顶点的关联数据之后，如果同时激活了细分着色器（tessellation shader），那么它将进一步处理这些数据。细分着色器会使用Patch来描述一个物体的形状，并且使用相对简单的Patch几何体连接来完成细分的工作，其结果是几何图元的数据增加，并且模型的外观会变得更为平顺。细分着色阶段会用到两个着色器来分别管理Patch数据并生成最终的形状。

##3.几何着色

几何着色允许在光栅化之前对每个图元做更进一步的处理，例如创建新的图元，这个着色阶段是可选的。

##4.图元装配

前面介绍的着色阶段所处理的都是顶点数据，此外这些顶点之前如何构成几何图元的所有信息也会被传递到OpenGL当中。图元装配阶段将这些顶点与相关的几何图元之间组织起来，准备下一步的剪切和光栅化工作。

##5.剪切

顶点可能会落在视口（viewport）之外--也就是我们可以进行绘制的窗口区域--此时与顶点相关的图元会做出改动，以保证相关的像素不会在视口外绘制。这一过程叫做剪切（clipping），它是由OpenGL自动完成的。

##6.光栅化

剪切之后马上要执行的工作，就是将更新后的图元传递到光栅化单元，生成对应的片元，我们可以将一个片元视为一个“候选的像素”，也就是可以放置在帧缓存中的像素，但是它也可能被最终剔除，不再更新对应的像素位置。

##7.片元着色

最后一个可能通过编程控制屏幕上显示颜色的阶段，叫做片元着色阶段。在这个阶段中，我们使用着色器来计算片元的最终颜色。和它的深度。片元着色器非常强大，在这里我们会使用纹理映射的方式，对顶点处理阶段所计算的颜色值进行补充。如果我们觉得不应该继续绘制某个片元，在片元着色器中还可以终止这个片元的处理，这一步叫做片元丢弃（discard）。为了更好的理解顶点颜色器和片元着色器之间的区别，可以用这种方式来记忆：顶点着色（包括细分和几何着色）决定了一个图元应该位于屏幕的什么位置，而片元着色使用这些信息来决定某个片元的颜色应该是什么。

##8.逐片元的操作

除了我们在片元着色器里做的工作之外，片元操作的下一步就是最后的独立片元处理过程。在这个阶段里会使用深度测试（depth test，也称作z-buffering）和模版测试（stencil test）的方式来决定一个片元是否是可见的。如果一个片元成功通过了所有激活的测试，那么它就可以被直接绘制到帧缓存中了，它对应的像素颜色（也可能包括深度值）会被更新，如果开启了融合（blending）模式，那么片元的颜色会与该像素当然的颜色相叠加，形成一个新的颜色值并写入帧缓存中。像素数据的传输也有一条路径。通常来说，像素数据来自图像文件，尽管它也可能是OpenGL直接渲染的。像素数据通常保存在纹理贴图当中，通过纹理映射的方式调用。在纹理阶段中我们可以从一张或者多张纹理贴图中查找所需的数据值。